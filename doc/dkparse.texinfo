\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename dkparse.texi
@settitle Dkparse 1.0
@c %**end of header

@macro lpm
@ifnottex
  lambda-Pi modulo@c
@end ifnottex
@iftex
  @tex
  $\\lambda\\Pi$-modulo%
  @end tex
@end iftex
@end macro

@copying
This manual is for Dkparse version 1.0, a type checker
for the @lpm{}.

@c Copyright @copyright{} 2012 Quentin Carbonneaux.

@c @quotation
@c Insert license note here.
@c @end quotation
@end copying

@titlepage
@title User Manual
@author Quentin Carbonneaux
@c Start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Print the toc.
@contents

@ifnottex
@node Top
@top Dkparse
@insertcopying
@end ifnottex

You can retrieve this software at @url{http:/github.com/mpu/dkparse}.

@menu
* Installation:: How to install the Dkparse program
* Overview:: A fast tour of the Dedukti framework
* Input files:: A description of files accepted by Dkparse
* Separate compilation:: How to use the module system
* Index::
@end menu

@node Installation
@chapter Installation
Some programs are required to get a working system, and some
others are required to build the Dkparse program.

To build Dkparse both GNU Bison (the grammar compiler), and a
C99 compliant compiler are needed, the build process is started
by the @command{make} command. Here is how you should build
Dkparse on a system where the required tools are installed:
@example
  make dkparse
@end example
The program resulting from this build process can be tested
with the @command{make test} command (Lua is needed).

To install Dkparse you will need to get Lua (or Luajit). Then, modify
the header of the @file{Makefile} file distributed with Dkparse in
order to adapt it to your local system. Finally, run @command{make install}
with appropriate privileges to start the installation process.

@node Overview
@chapter Overview
@cindex Dkparse

@dfn{Dkparse} is a fast type checker of the @lpm{},
it relies on the normalization by evaluation compilation
technique.

Type checking a Dedukti file is done in two phases, first the
input file needs to be converted to a Lua program. Second, this
Lua program is executed by a Lua interpreter enriched with the
Dedukti runtime.

Translating a Dedukti file in Lua source code
is acheived by the Dkparse program, to translate @file{theory.dk}
and store the resulting Lua code in @file{t.lua}, run the
following command @command{dkparse theory.dk > t.lua}. If your
input file is a valid Dedukti file with respect to syntactic
constraints, 0 is returned, otherwise, a failure is
signaled by a 1 return code. @xref{Syntax}, to get the list of
constraints a Dedukti file must respect.

To run the freshly translated Lua file, use the Lua interpreter
enriched with Dedukti's runtime: @command{lua -l dedukti t.lua}.
If the input @file{.dk} file is correctly typed, 0 is returned,
otherwise 1 is returned. The @option{-l} option force Lua to load
the Dedukti runtime.

The idiomatic command to type check a file
@file{theory.dk} is @code{dkparse theory.dk | lua -l dedukti -},
this avoids creating a useless intermediate file.
Note that by default, shell pipe's return code is the one of
the last command, hence, if @samp{dkparse theory.dk} fails in
the previous command but @samp{lua -l dedukti -} succeeds, 0
is returned and no error is signaled. Because of this, we
recommand to first run @samp{dkparse theory.dk > /dev/null}
and check the return code.
@quotation Note
Some shells (like GNU Bash) have a @code{pipefail} option which
will force pipe commands to return an error if a process in the
pipe fails. If you have such a shell, you don't need to first
run the @samp{dkparse theory.dk > /dev/null} command.
@end quotation

@c As a simple startup example you could try to type check the
@c following file using commands described above.
@c @example
@c   Bool : Type.
@c   True : Bool.
@c   False : Bool.

@c   not : Bool -> Bool.
@c   [] not True --> False
@c   [] not False --> True.
@c @end example
@c You should get a colored output telling that the terms defined
@c in your input file were correctly typed.

@node Input files
@chapter Input files
Files accepted by Dkparse represent a theory expressed in the
@lpm{}, if the syntax or scoping constraints are not
respected, the Dkparse program will signal it. However, if the input
file is ill typed but expressed with the correct syntax and well
scoped, it is the Lua program generated by Dkparse which will fail
once ran. Dedukti file names must end in @file{.dk}.

@menu
* Syntax::
* Scoping::
@end menu

@node Syntax
@section Syntax
@subsection Syntax overview
@cindex Rewrite rule
@cindex Declaration

A valid @file{.dk} file is a list of declarations and rewrite rules.
Declarations declare a given identifier with a given type. They
are of the form @code{id : type.}. A simple example of such a
declaration is @code{Bool : Type.}, this declares a new type
called @samp{Bool}. To add constants of type bool, use the
same syntax.
@example
  True : Bool.
  False : Bool.

  not : Bool -> Bool.
  and : Bool -> Bool -> Bool.
@end example

Rewrite rules define the behavior of defined constants. They are
defined by pattern matching as it can be found in common functional
languages. All rules concerning a given identifier must be given a
sequence terminated by a '.' character.
@example
  [] not True --> False
  [] not False --> True.

  [b : Bool] and False b --> False
  [b : Bool] and True b --> b.
@end example
As you can see, all rewrite rules are preceded by a context giving
the type of variables used in the left hand side pattern of a rewrite
rule.

Comments in a Dedukti file are separated by @code{(;} and
@code{;)}, they can be inlined everywhere and must not be
nested (for the sake of parsing simplicity, and to avoid
commenting whole sections of Dedukti code).

@subsection Formal grammar
In a more formal fashion, the grammar of files accepted by Dkparse is
shown below, the contents of a valid @file{.dk} file must match the
@code{top} entry in the grammar.

@verbatim
top: /* empty */
   | top decl '.'
   | top rules '.'

rules: rule
     | rules rule

decl: ID ':' term

rule: '[' bdgs ']' pat LONGARROW term

bdgs: /* empty */
    | bdgs ',' ID ':' term
    | ID ':' term

pat: ID dotps spats

dotps: /* empty */
     | dotps '{' term '}'

spats: /* empty */
     | spats spat

spat: ID
    | '(' pat ')'

sterm: ID
     | '(' term ')'
     | TYPE

app: sterm
   | app sterm

term: app
    | ID ':' app ARROW term
    | term ARROW term
    | ID ':' app FATARROW term
    | ID FATARROW term
@end verbatim

In the grammar listed above, terminal symbols are given
in upper case, here are their corresponding definitions:

@verbatim
LONGARROW ::= '-->'
ARROW     ::= '->'
FATARROW  ::= '=>'
ID        ::= (letter* '.')* letter (letter | quote)*

letter    ::= [a-zA-Z] | '_'
quote     ::= '\''
@end verbatim

@subsection Qualified identifiers
@cindex Qualified identifier

Qualified identifiers (identifier containing the '.' character) are
used to make cross module references. All references must be made
relative the the root of the current project. While the syntax
allows to use qualified identifiers in a binder, this is bad practice
and will probably be forbidden in future versions of Dkparse.

@node Scoping
@section Scoping
Dkparse will check that its input file is well scoped before
translating it into a Lua program. All identifiers used must
either, be qualified, have already been declared in the current
file, or have been bound by one of the binders. Binders in the
files read by Dkparse include
@itemize
@item
  Lambda bindings (@code{x : T => ...} or @code{x => ...})
@item
  Pi bindings (@code{x : T -> ...})
@item
  Rule environments (@code{[x : T] foo x --> ...})
@end itemize
Input files must also respect a list of well formation rules
@itemize
@item
  All identifiers must be declared at most once.
@item
  All identifiers must be defined (with rewrite rules) at most
  once.
@item
  All variables in a rule environment must appear exactly once as
  pattern variables in the left hand side of a rule. This implies
  that non linear patterns are not allowed.
@item
  All constructors must appear with the same arity in the left
  hand side of rewrite rules.
@end itemize

@quotation Warning
Currently, Dkparse does not check scoping across modules. This
means that qualified identifiers are assumed to be in scope.
@end quotation

@node Separate compilation
@chapter Separate compilation
@cindex Separate compilation
@cindex Module system

Dkparse features a simple @dfn{module system} with
packages. Modules are represented as independent files and
packages (which can be nested) are represented by
directories. This module system allows to separate code in
different logical units. This can be used to separate a
theory and its theorems. Using a fine grained modularization
of code also allows to type check smaller files and to avoid
type checking huge amounts of code when only one or two
terms were changed.

Module cross references are made relative to the project
root. The @dfn{project root} is a directory which contains all
module files of the current project (possibly in sub
directories).

To access an identifier in another module one must give the
full chain of packages and the name of the module containing
this identifier. The '.' character is used as a separator
in access paths.

As a running example we will use the following file hierarchy:
Three modules are defined @file{A.dk}, @file{D/B.dk} and
@file{D/C.dk}; the following dependency chain is assumed:
@clicksequence{@file{D/C.dk} @click{} @file{A.dk} @click{}
@file{D/B.dk}}, where @clicksequence{A @click{} B} means that
A depends on B. If @code{id} is declared in @file{D/B.dk},
to use it in the file @code{A.dk} it must be designated as
@code{D.B.id}.

@section Type checking
Type checking of several modules can be made in a row.
Dkparse, when given several input file will generate Lua
code needed to type check all modules in the order specified
by the user. To typecheck a bunch of modules in a row one
first needs to do a topological sort on the partial order of
dependencies, in our example we have a total order.
To generate Lua code to type check the running example use
the following command at your project root:
@example
  dkparse D/B.dk A.dk D/C.dk
@end example
You probably want to execute the Lua code generated on the
standard output, if so, pipe the output of the previous
command to the @command{lua -l dedukti -} command. It is
mandatory to run the command at your project root, otherwise
extra directories in paths given to Dkparse will be
interpreted as package names.

@quotation Reminder
The order of arguments passed to the @command{dkparse} command
@emph{does matter}. This command must be launched at the project
root.
@end quotation

@section Compiling
Using the previous approach, all files in the current project
must be type checked each time one is modified. To avoid this
extra cost, some modules can be compiled.

Let's assume you are working on @file{D/C.dk}, then type checking
the two other files in your project each time you make a change
in your file is worthless. In this situation you want to
@dfn{compile} these two files.

Before compiling a file it must be type checked, otherwise, the
code produced is not guaranteed to be valid. So, before running
the following commands, type check the two dependences of
@file{D/C.dk} using commands explained in the previous section.

Compilation of Dedukti source files is enabled when Dkparse is
used with the @option{-c} option. In this case, a small Lua
file is generated in the same directory as the one of the input
file. Once again @emph{Dkparse must be launched in the root
directory of the project}. Thus, you can compile the two
dependeces with the following command.
@example
  dkparse -c A.dk D/B.dk
@end example
Note that when ran with the @option{-c} flag the order of input
files does not matter. Indeed, this is separate compilation:
nothing about other modules is needed when Dkparse compiles one.

If the file @file{D/C.dk} was freshly modified, you can type
check it using the two previously compiled modules with the
following command:
@example
  dkparse D/C.dk | lua -l dedukti -l D.B -l A -
@end example
As already mentioned, the @option{-l} option forces Lua to load
the specified modules. When loading these modules, the order
matters: the module @samp{A} depends on the module
@samp{D.B}, hence the latter appears before @samp{-l A} in the
command line. Note that arguments of the Lua command are not
file names but module names, hence the use of '.' to access
them across packages and the lack of @file{.lua} extension.

@quotation Reminder
The order of arguments passed to @command{dkparse -c} @emph{does
not matter}, while the order of arguments passed to
@command{lua} @emph{does matter}. These two commands must be
lauched at the project root.
@end quotation

@node Index
@unnumbered Index
@printindex cp
@bye
